# web服务器原理

## 前言

web服务器就运行在服务器主机的操作系统里的一个处理网络请求的程序，最主要处理的就是http请求

http请求的目的

  - 获取后端业务数据
  - 反向代理
    反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet上 的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。
  - 负载均衡
    当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。
  - 静态文件托管
    静态资源的服务器，代理访问文件

那么一个web服务器它是怎么工作，它会碰上什么问题？

## 协议

web服务器主要是接收通过http协议发过来的数据，所以这里先简单普及一下http，详情的可以看后面的分享。

首先http基于tcp，tcp是网络层的协议，http是应用层协议。
在tcp建立连接的基础上，才能开始应用http协议

每发起一个http请求，都需要在客户端和服务器建立一个tcp连接管道，用以传输http报文。
由于tcp是有状态的连接，所以服务器需要内存资源来保持一个开启的tcp连接管道。

|-- 服务器 --|
| <tcp>    |
| <tcp>    |
| <tcp>    |
|----------|


## 服务器和端口号

端口是设备与外界通讯交流的出入口

在日常开发中我们常说的端口实际都是tcp协议的端口，用于区分处理tcp协议的程序，如80，8080等

通常情况下，服务器开机启动的会有超级进程用以收取tcp请求

当一个tcp/发送过来时，超级进程会接收这个请求并根据端口号，确认这个端口是否有httpd程序申请了监听这个端口号

如果有程序趴在这个端口上监听，然后再转发这个这个请求数据到对应的httpd程序进程，这个httpd程序进程通常就是我们说的web服务，如nginx，tomcat，nodejs的net/http模块，apache httpd

[此处有图]


## web服务器工作

初的服务器都是基于进程/线程模型的，新到来一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。如果是有1万个请求就要创建1万个进程，那么操作系统是无法承受的。如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook，Google才有财力购买如此多的服务器。

这经典的C10K问题。


示例: apache httpd（服务端） + php（执行脚本）

请求处理过程演示

[此处有图]

## 进程，线程

进程 -> 线程1
    -> 线程2
    -> 线程3

创建进程是系统级操作，创建线程是进程内操作
新建一个进程 远大于 新建 一个线程 大于 本线程内直接处理

在linux 或 mac操作执行ps -ef 可以看到当前正在运行的所有进程

进程因为系统级的，所以它能做的事情非常多，获得系统的资源，状态，跟其它进程通信等。。

基于进程和线程的特性，常见的web服务器会采用不同的进程策略模型，

- 经典的 apache httpd + php
  - 多进程单线程
    - 全新的上下文执行环境，
    - 进程之间，不会相互影响

    - 占用系统资源多
    - 进程间不能简单直接共享数据
    - 脚本执行效率低

- 主流的 tomcat + java
  - 单进程多线程
    - 多线程编程模式功能强大，充分利用资源
    - 支持更高的并发，受限于tomcat线程池设定
    - 程序执行效率高

    - 多线程会引发线程安全问题，线程之间相互影响
    - 创建一个线程也需要消耗资源

- 强大的 nodejs http + JavaScript
  - 单进程单线程
    - 资源占用小
    - 支持超高的并发

    - 维护难度max，共享内存引发连锁噩梦
    - 脚本执行效率低











e
